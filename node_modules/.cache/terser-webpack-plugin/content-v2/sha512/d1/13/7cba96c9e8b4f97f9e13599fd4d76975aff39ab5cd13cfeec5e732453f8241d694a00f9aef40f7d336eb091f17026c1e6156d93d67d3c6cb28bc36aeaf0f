{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{177:function(e,t,r){\"use strict\";r.r(t);var _=r(0),a=Object(_.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"div\",{staticClass:\"content\"},[r(\"h2\",{attrs:{id:\"zookeeper-分布式协调服务器\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#zookeeper-分布式协调服务器\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Zookeeper -分布式协调服务器\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"官方文档：\"),r(\"code\",[e._v(\"https://zookeeper.apache.org/doc/current/index.html\")])])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"概述\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#概述\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 概述\")]),e._v(\" \"),r(\"h4\",{attrs:{id:\"zookeeper-是什么\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#zookeeper-是什么\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Zookeeper 是什么\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：\"),r(\"code\",[e._v(\"配置维护\")]),e._v(\"、\"),r(\"code\",[e._v(\"域名服务\")]),e._v(\"、\"),r(\"code\",[e._v(\"分布式同步\")]),e._v(\"、\"),r(\"code\",[e._v(\"组服务\")]),e._v(\"等。\")])]),e._v(\" \"),r(\"h4\",{attrs:{id:\"zookeeper可以做什么\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#zookeeper可以做什么\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Zookeeper可以做什么\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[e._v(\"分布式服务注册与订阅\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，比较典型的服务注册与订阅，代表：dubbo。\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"分布式配置中心\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者获取数据，实现配置信息的集中式管理和动态更新。代表：百度的disconf（苏宁 SCM?）。\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"命名服务\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，进程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"分布式锁\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。\")]),e._v(\" \"),r(\"li\",[e._v(\"所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。\")]),e._v(\" \"),r(\"li\",[e._v(\"控制时序，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已绊预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"Master选举\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"负载均衡\")])])])])}],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}