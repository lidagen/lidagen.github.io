## RabbitMQ 基础

### RabbitMQ 特性与好处
+ 任务异步处理
+ 应用程序的解耦
+ 削峰填谷
#### 
#### RabbitMQ 与 Erlang
+ RabbitMQ是基于Erlang语言开发的消息代理服务器，Erlang被设计成一种分布式、高容错的软实时系统，作为一种开发语言，Erlang专注于节点之间消息通信的轻量级进程,提供了状态无关的高并发性。
+ Erlang的分布式通信架构天然可以构建RabbitMQ集群机制，RabbitMQ集群中服务器充分利用Erlang进程间通信，而其它消息代理服务器不得不自己实现集群功能。

#### RabbitMQ 与 AMQP
+ AMQP 是一个提供统一消息服务的应用层标准高级消息队列协议，并不受客户端/中间件同产品，不同的开发语言等条件的限制。通过 AMQP, RabbitMQ 致力于成为 与供应商无关、平台独立的解决方案。

### 消息队列模型
+ RabbitMQ的强大性和灵活性来自与AMQP协议，该规范不仅定义了一种网络协议，还定义了服务端的服务和行为，这些信息就是高级队列（Adcancee Message Quenuing AMQ）模型，针对代理服务软件，AMQ模型在逻辑上定义了三个抽象组件用于指定消息的路由行为：
  - `交换器（Exchange）`,消息队列服务器中用于把消息路由到队列的组件。
  - `队列（Queue）`,用于储存消息的数据结构，位于硬盘或者内存中。
  - `绑定（Binding）`,一套规则，用于告诉交换机消息应该被存储在哪个队列。
+ **交换器**
  - 交换器是接收RabbitMQ中的消息并决定把它们投递到何处。交换器定义消息的路由行为，通常这需要检查消息所携带的数据特性或者包含在消息体内的各种属性。
+ **队列**
  - 队列负责存储接收的消息，同时也可能包含如何处理消息的配置信息，队列可以把消息只存储在内存中，也可以存储在硬盘中，然后以先进先出（FIFO）的顺序投递。
+ **绑定** 
  - AMQ中绑定用来定义队列和交换器之间的关系。在RabbitMQ中，绑定键（binding-key）告知交换器要投递消息到哪个队列，当发布消息到交换器时，应用程序使用路由键（routing-key）属性。当交换器对一条消息进行评估决定路由到哪个队列时，消息的路由键和绑定键进行对比。


### RabbitMQ的工作模式
#### 1.工作队列模式
+ 生产者生产消息放在队列queue中，多个消费者消费，消息不会重复发给多个消费者
+ 默认情况下，rabbitmq将会按顺序派发每个任务给下一个消费者，平均而言，每个消费者将获得相同数量的消息，这种分发消息的方式称为轮询。

#### 2.发布订阅模式
+ 发布订阅模式，多了一个exchange（交换机）角色，交换机拿到消息，知道如何处理消息（递交给所有队列、递交给某个特别队列、丢弃消息），这取决于交换机的类型
  - Fanout:广播，将消息投递给所有绑定倒交换机的队列
  - Direct:定向，把消息投递给符合指定routing key的队列
  - Topic:通配符，把消费交给符合routing pattern的队列
:::tip
如果没有任何队列与交换机绑定，或没有符合的路由规则则消息会被丢弃
:::

#### 3.路由模式
+ 队列和交换机的绑定不是任意绑定了，而是指定一个routing key
+ 消息发送，必须指定routing key 
+ 只有队列routing key与消息的routing key一致，交换机才会发送消息
#### 4.通配符模式
+ 通配符也是根据routing key把消息路由不同队列，只不过Topic类型exchange可以让队列绑定routing key时使用通配符
+ routing key 一般是多个单词组成，单词以‘.’分割，例如：item.insert
  - 通配符规则
    + #：匹配一个或多个词
    + *：匹配不多不少恰好1个词
:::tip
+ item.#  可以匹配item.insert 和 item.insert.abc
+ item.*  只匹配item.insert
:::    
